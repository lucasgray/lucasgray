<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Charts | lucasgray.github.io</title>
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="Charts" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Fun with d3 and typescript" />
<meta property="og:description" content="Fun with d3 and typescript" />
<link rel="canonical" href="http://localhost:4000/projects/execvision/charts.html" />
<meta property="og:url" content="http://localhost:4000/projects/execvision/charts.html" />
<meta property="og:site_name" content="lucasgray.github.io" />
<script type="application/ld+json">
{"headline":"Charts","url":"http://localhost:4000/projects/execvision/charts.html","description":"Fun with d3 and typescript","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <link rel="stylesheet" href="/assets/css/style.css?v=a88736f7aa72e93c0f564b8b48f70424552ce9ca">
    <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://localhost:4000/">lucasgray.github.io</a></h1>
        
        

        <p></p>

        
        <p class="view"><a href="https://github.com/lucasgray/lucasgray.github.io">View the Project on GitHub <small>lucasgray/lucasgray.github.io</small></a></p>
        

        

        
      </header>
      <section>

      <h1 id="ev-charts"><code class="language-plaintext highlighter-rouge">ev-charts</code></h1>

<p><code class="language-plaintext highlighter-rouge">ev-charts</code> is an npm library I built for ExecVision to house all our d3 react components.  We primarily use d3 as a library and build <code class="language-plaintext highlighter-rouge">&lt;svg/&gt;</code> elements declaratively in typescript-aware react components. Here are a few fun examples -</p>

<h2 id="9-box">9 box</h2>

<p>The 9 box chart is meant to answer the fundamental question - “Who should I coach?” Managers only have so much time in the day, and you want to focus your attention on employees that</p>

<ol>
  <li>Have room to improve</li>
  <li>Show willness (through self review)</li>
</ol>

<p>Since we can ascertain these two metrics through usage in the app, we plot them as the x and y on a scatter plot  (this is all based on an <a href="https://www.shrm.org/resourcesandtools/tools-and-samples/hr-qa/pages/whatsa9boxgridandhowcananhrdepartmentuseit.aspx">HR talent philosophy</a>)</p>

<p>Here is a happy example of the resulting output. Note that the suggestion would get dynamically rendered based on where the teams fell in the plot.</p>

<p><img src="/assets/ev-charts/9box.png" alt="9 box happy" /></p>

<p>The following snippet is the high level <code class="language-plaintext highlighter-rouge">AvatarScatterPlot</code> <code class="language-plaintext highlighter-rouge">render()</code> method. I like how clean it turned out:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;FlexWrapper&gt;
    &lt;Chart
        bordered={false}
        margins={margins}
        svgDimensions={svgDimensions}
    &gt;
        &lt;PerformanceQuadrants scales={scales} margins={margins}/&gt;

        &lt;CleanArrowLeftAxis scales={scales} margins={margins} svgDimensions={svgDimensions}
                            label={`Self-review Score ⟶`}
        /&gt;
        &lt;CleanArrowBottomAxis scales={scales} margins={margins} svgDimensions={svgDimensions}
                                label={"Activity Score ⟶"}
        /&gt;

        {reps.map(({rep, coordinate, additionalInfo}, i) =&gt;
            &lt;FancyAvatarPoint key={i}
                                scales={scales} coordinate={coordinate}
                                highlight={shouldHighlight(coordinate)} rep={rep}
                                additionalInfo={additionalInfo} defaultAvatar={defaultAvatar}
            /&gt;
        )}
        {repsWithoutPlans.length !== 0 &amp;&amp; arrowPointer &amp;&amp; arrowDelta &amp;&amp; &lt;CalloutArrow
            from={arrowPointer}
            to=
            delta={arrowDelta}
        /&gt;}
    &lt;/Chart&gt;
    &lt;AdditionalInfo&gt;
        &lt;CalloutCard
            title="Who to coach?"
            extra={this.getExtraTooltipInfo(repsWithoutPlans)}
        /&gt;
        &lt;AvatarScatterPlotLegend/&gt;
    &lt;/AdditionalInfo&gt;
&lt;/FlexWrapper&gt;
</code></pre></div></div>

<h2 id="exec-talklisten-heatmap">Exec talk/listen heatmap</h2>

<p>This is a heatmap that rolls up the organization into certain quadrants based on a couple of call metric ratios - their talk/listen ratio on a call vs interchanges.  We think there is an optimal amount of both, so we made a little callout area in the heatmap.</p>

<p>Here are a few relatively boring storybook examples:</p>

<p><img src="/assets/ev-charts/heatmap1.png" alt="heatmap 1" />
<img src="/assets/ev-charts/heatmap2.png" alt="heatmap 2" /></p>

<p>One interesting piece of the build out of this component - I built a typescript HoC that could accept a list of user metrics of this shape:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export interface UserTalkListen {
    user: User,
    talkListen: number,
    interchanges: number
}
</code></pre></div></div>

<p>and bridge the gap to the “pure” heatmap component that rendered “buckets”/cells:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export interface HeatmapProps {
    data: number[][]
    bucketBounds: BucketBounds,
    bucketCallout?: BucketCallout,
    onClickCell: (c: Cell) =&gt; void,
    onDoubleClickCell?: (c: Cell) =&gt; void
}
</code></pre></div></div>

<p>It was initially meant to provide zoom functionality as well but was later scrapped.  The HoC typing looked like this, just to give you an idea</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>interface Zoomable {
    onZoomIn: (c: Cell) =&gt; void,
    onZoomOut: () =&gt; void,
    onZoomReset: () =&gt; void
}

export interface WithBucketingProps extends Zoomable {
    reps: UserTalkListen[],
    bucketBounds: BucketBounds,
    bucketCallout?: BucketCallout,
    onSelectReps: (users: User[]) =&gt; void,
}

export interface WithBuckets {
    data: number[][],
    onClickCell: (c: Cell) =&gt; void,
    onDoubleClickCell?: (c: Cell) =&gt; void
}

export interface ZoomLevel {
    // yes i know the 3d array looks crazy, but 2d was to render the x&amp;y, and the
    // 3rd was to store the underlying reps to display next to the graph on click!
    // note this was collapsed to 2d when passing down so the underyling component
    // didnt have to care
    buckets: UserTalkListen[][][],
    bucketBounds: BucketBounds
}

/**
 * HoC that wraps the heatmap and provides "pure" and simple data to it,
 * keeping track of the bucketed data it was given.
 *
 * Later provide zoom through this guy too (since this has bucketbounds and reps)
 *
 * @param Component - a (presumably heatmapish) component that supports getting a 2d array of data
 */
export const withBucketing = &lt;P extends WithBucketingProps, U extends WithBuckets&gt;(Component: React.ComponentType&lt;U&gt;) =&gt; {

    return class WithBucketing extends React.Component&lt;P &amp; U, {zoomLevels: Stack&lt;ZoomLevel&gt;}&gt; {

        constructor(props: P &amp; U) {
            super(props);

            this.state = {
                zoomLevels: new Stack&lt;ZoomLevel&gt;()
            };
        }

        // ... this component would bucket / transform and pass off to the wrapped component
    }
}
</code></pre></div></div>

<h2 id="trend-sparklines">Trend sparklines</h2>

<p>Everybody loves their sparklines, especially when they go up and to the right. We revamped ours a few times and eventually settled on a scatterplot looking chart, drawing a curved “fit” line to help the user make sense of the trend.</p>

<p>When looking at one trend in particular, we’d show the underlying data.</p>

<p><img src="/assets/ev-charts/sparkline-singular.png" alt="sparkline 1" /></p>

<p>If we showed multiple for you to compare, we’d hide the underlying data until you hovered/pinned on the trend.</p>

<p><img src="/assets/ev-charts/sparkline-multiple.png" alt="sparkline 2" /></p>

<p>No sparkline is complete without fancy animations -</p>

<video controls="" width="500">
    <source src="/assets/ev-charts/sparkline-draw.mp4" />
</video>

<h2 id="progress-circle">Progress circle</h2>

<p>Nothing fancy, just a nice little animated progress circle that does what you want.</p>

<video controls="" width="500">
    <source src="/assets/ev-charts/progress-circle.mp4" />
</video>


      </section>
      <footer>
        
        <p>This project is maintained by <a href="https://github.com/lucasgray">lucasgray</a></p>
        
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="/assets/js/scale.fix.js"></script>
    
  </body>
</html>
